val unit = func (lay) {
    val L, C = (#lay, #lay[1])
    val ret = @{}
    loop l in L {
        loop c in C {
            val nxt = #ret + 1
            if lay[l][c] == nxt {
                val r = @{x=c,y=l,w=nil,h=nil}
                loop cx in (c,C) {
                    until (lay[l][cx] != nxt)
                    set r.w = (cx - c) + 1
                }
                loop lx in (l,L) {
                    until (lay[lx][c] != nxt)
                    set r.h = (lx - l) + 1
                }
                set ret[+] = r
            }
        }
    }
    ret
}

val mult = func (lay, ref, rs) {
    val ret = @{}
    val px,py = (ref.w/#lay[1], ref.h/#lay)
    loop i,r in rs {
        set ret[+] = @{x=x,y=y,w=w,h=h} where {
            w = r.w * px
            h = r.h * py
            x = ref.x + ((r.x-1) * px)
            y = ref.y + ((r.y-1) * py)
        }
    }
    ret
}

val tags = func (ids, ms) {
    assert(#ms == #ids)
    val ret = @{}
    loop i,r in ms {
        set ret[ids[i]] = r
    }
    ret
}

func layout (ids, lay, ref) {
    set ref = assert(ref)
    val us = unit(lay)
    val ms = mult(lay, ref, us)
    if ids => tags(ids, ms) => ms
}

;;;
task Grid (rs) {
    spawn {
        every :Pico.Draw {
            pico.set.style(:Style.Stroke)
            loop r in rs {
                pico.output.draw.rect(r)
            }
        }
    }
    await(|false)
}
;;;

test {
    do {
        print "Test 1..."
        val lay = @{
            @{1, 2}
        }
        val us = unit(lay)
        assert(us === @{
            @{x=1,y=1,w=1,h=1},
            @{x=2,y=1,w=1,h=1},
        })

        val m1 = mult(lay, @{x=0,y=0,w=2,h=1}, us)
        assert(m1 === @{
            @{x=0,y=0,w=1,h=1},
            @{x=1,y=0,w=1,h=1},
        })

        val ts = tags(@{:l, :r}, m1)
        assert(ts.l === @{x=0,y=0,w=1,h=1})
        assert(ts.r === @{x=1,y=0,w=1,h=1})

        val m2 = layout(@{:l,:r}, lay, @{x=0,y=0,w=2,h=1})
        assert(m2 === @{
            l = @{x=0,y=0,w=1,h=1},
            r = @{x=1,y=0,w=1,h=1},
        })

        val m3 = layout(@{:l,:r}, lay, @{x=100,y=200,w=10,h=10})
        assert(m3 === @{
            l = @{x=100,y=200,w=5,h=10},
            r = @{x=105,y=200,w=5,h=10},
        })
    }

    do {
        print "Test 2..."
        val lay = @{
            @{1,1,2},
            @{1,1,2},
            @{3,3,4},
            @{5,6,4},
        }
        val rs = layout(nil, lay, @{x=0,y=0,w=30,h=40})
        assert(rs === @{
            @{x=00,y=00,w=20,h=20},
            @{x=20,y=00,w=10,h=20},
            @{x=00,y=20,w=20,h=10},
            @{x=20,y=20,w=10,h=20},
            @{x=00,y=30,w=10,h=10},
            @{x=10,y=30,w=10,h=10}
        })
    }

    do {
        print "Test 3..."
        val lay = @{
            @{1,1,2},
            @{1,1,2},
            @{3,3,4},
            @{5,6,7},
        }
        val rs = layout(nil, lay, @{x=0,y=0,w=30,h=40})
        assert(rs === @{
            @{x=00,y=00,w=20,h=20},
            @{x=20,y=00,w=10,h=20},
            @{x=00,y=20,w=20,h=10},
            @{x=20,y=20,w=10,h=10},
            @{x=00,y=30,w=10,h=10},
            @{x=10,y=30,w=10,h=10},
            @{x=20,y=30,w=10,h=10},
        })
    }
}

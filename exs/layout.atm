val pico = require "pico"

val M = @{}

val unit = func (lay) {
    val L, C = (#lay, #lay[1])
    val ret = @{}
    loop l in L {
        loop c in C {
            val nxt = #ret + 1
            if lay[l][c] == nxt {
                val r = @{x=c,y=l,w=nil,h=nil}
                loop cx in (c,C) {
                    until (lay[l][cx] != nxt)
                    set r.w = (cx - c) + 1
                }
                loop lx in (l,L) {
                    until (lay[lx][c] != nxt)
                    set r.h = (lx - l) + 1
                }
                set ret[+] = r
            }
        }
    }
    ret
}

val mult = func (lay, ref, rs) {
    val ret = @{}
    val px,py = (ref.w/#lay[1], ref.h/#lay)
    loop i,r in rs {
        set ret[+] = @{x=x,y=y,w=w,h=h} where {
            w = r.w * px
            h = r.h * py
            x = ref.x + ((r.x-1) * px)
            y = ref.y + ((r.y-1) * py)
        }
    }
    ret
}

func M.layout (lay, ref) {
    val us = unit(lay)
    val ms = mult(lay, ref, us)
    ms
}

func M.Grid (rs) {
    every :draw {
        pico.zet.style(:stroke)
        pico.zet.anchor.draw(:left, :top)
        loop _,r in rs {
            pico.output.draw.rect(r)
        }
    }
}

test {
    do {
        print "Test 1..."
        val lay = @{
            @{1, 2}
        }
        val us = unit(lay)
        assert(us === @{
            @{x=1,y=1,w=1,h=1},
            @{x=2,y=1,w=1,h=1},
        })

        val m1 = mult(lay, @{x=0,y=0,w=2,h=1}, us)
        assert(m1 === @{
            @{x=0,y=0,w=1,h=1},
            @{x=1,y=0,w=1,h=1},
        })

        val m3 = M.layout(lay, @{x=100,y=200,w=10,h=10})
        assert(m3 === @{
            @{x=100,y=200,w=5,h=10},
            @{x=105,y=200,w=5,h=10},
        })
    }

    do {
        print "Test 2..."
        val lay = @{
            @{1,1,2},
            @{1,1,2},
            @{3,3,4},
            @{5,6,4},
        }
        val rs = M.layout(lay, @{x=0,y=0,w=30,h=40})
        assert(rs === @{
            @{x=00,y=00,w=20,h=20},
            @{x=20,y=00,w=10,h=20},
            @{x=00,y=20,w=20,h=10},
            @{x=20,y=20,w=10,h=20},
            @{x=00,y=30,w=10,h=10},
            @{x=10,y=30,w=10,h=10}
        })
    }

    do {
        print "Test 3..."
        val lay = @{
            @{1,1,2},
            @{1,1,2},
            @{3,3,4},
            @{5,6,7},
        }
        val rs = M.layout(lay, @{x=0,y=0,w=30,h=40})
        assert(rs === @{
            @{x=00,y=00,w=20,h=20},
            @{x=20,y=00,w=10,h=20},
            @{x=00,y=20,w=20,h=10},
            @{x=20,y=20,w=10,h=10},
            @{x=00,y=30,w=10,h=10},
            @{x=10,y=30,w=10,h=10},
            @{x=20,y=30,w=10,h=10},
        })
    }

    do {
        print "Grid 1..."
        require "atmos.env.pico"
        pico.zet.size.window(@{x=500,y=500}, @{x=100,y=100})
        val lay = @{
            @{1,1,2},
            @{1,1,2},
            @{3,3,4},
            @{5,6,7},
        }
        val rs = M.layout(lay, @{x=0,y=0,w=100,h=100})
        spawn M.Grid(rs)
        await(:key.dn, :Escape)
    }
}

M

require "atmos"
val x = require "atmos.x"
val pico = require "pico"
require "atmos.env.pico"
val S = require "atmos.streams"
val SDL = require "SDL"

pico.zet.title "pico-Atmos: Clicks"
pico.zet.size.window(256, 256)

var txts = @{}

var rect = @{x=256/2,y=256/2, w=20,h=20}

spawn {
    par {
        every :draw {
            pico.output.draw.rect(rect)
            val pt = pico.pos(80,10)
            loop _,t in txts {
                pico.output.draw.text(pt, t)
                set pt.y = pt.y + 15
            }
        }
    } with {
        every m in :mouse.motion {
            set rect.x = m.x
            set rect.y = m.y
        }
    }
}

spawn {
    ;;;
    ;;  - TODO: misturar solucoes
    ;;  - 24 lines, ~100 tokens
    ;;  - < XX tokens
    ;;  - event click silence of at least 250
    ;;  - Hot observable
    ;;  - :click.dn (pos, n)
    ;;      - N cliques espacados em 250ms na mesma posicao
    ;;      - caso a pos mude, reconheca como esta
    ;;      - somente apos 250ms um outro dn pode ser reconhecido
    ;;  - :click.up (pos, n)
    ;;      - reconhecido apenas apos um dn
    ;;      - em qq circunstancia
    ;;      - imediato apos dn se estado up
    ;;;
    loop {
        val _,dn = await :mouse.button.dn
        var n = 1
        watching :mouse.motion {
            loop {
                watching :mouse.button.dn {
                    await @.250
                    break()
                }
                set n = n + 1
            }
        }
        emit :x.mouse.button.dn @{ n=n, x=dn.x, y=dn.y }
        par_and {
            var state, x, y = SDL.getMouseState()
            if state[SDL.mouseMask.Left] {
                val _,pos = await :mouse.button.up
                set x,y = (pos.x, pos.y)
            }
            emit :x.mouse.button.up @{x=x,y=y}
        } with {
            await @.250
        }
    }
}

;; vamos comecar com o dclick simples

;; TODO: await(stream)

func Buffer (src, ctl) {
    val ret = @{}
    val v = await(src)
    set ret[+] = v
    watching ctl {
        every v in src {
            set ret[+] = v
        }
    }
    ret
}

func Debounce (src, ctl) {
    await(src)
    loop {
        watching src {
            await(ctl)
            break()
        }
    }
    return <- true
}

;;;
par {
    loop {
        await Debounce(_or_(SDL.event.MouseButtonDown,SDL.event.MouseButtonUp), @1)
        set txts = @{}
    }
} with {
    every _,pos,n in :sdl.mouse.button.dn {
        set txts[+] = "dn (" ++ pos.x++','++pos.y ++"): " ++ n
    }
} with {
    every _,pos in :sdl.mouse.button.up {
        set txts[+] = "up (" ++ pos.x++','++pos.y ++")"
    }
}

- fazer isso funcionar
- fazer throttle em IA
- mudar para IA aqui
- depois buffer, depois dclick
;;;

val clear =
    S.fr_await(Debounce, _or_(:mouse.button.dn,:mouse.button.up), @1)
        ::tap \{ set txts = @{} }

val dn = 
    S.fr_await(:x.mouse.button.dn)
        ::tap \{
            set txts[+] = "dn (" ++ it.x++','++it.y ++"): " ++ it.n
        }

val up =
    S.fr_await(:x.mouse.button.up)
        ::tap \{
            set txts[+] = "up (" ++ it.x++','++it.y ++")"
        }

S.from@{clear,dn,up}::xpar()::to()
await(false)

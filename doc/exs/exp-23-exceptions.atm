val ok, v = catch :X {
    42
}
print(ok, v)        ;; --> true, 42

val ok, x = catch :X {
    throw(:X @{v=10, msg="error"})
    print("unreachable")
}
print(ok, x.msg)    ;; --> false, error

func f () {
    throw :X.Y
}
val x =
    catch :X {
        catch :X.Z {
            defer {
                print "ok"
            }
            f()
        }
    }               ;; --> ok (from defer)
print(x)            ;; --> false

val ok, v = catch \{(true,42)} {    ;; catches any error, transforms into 42
    throw :X
}
print(ok, v)                        ;; --> false, 42

throw :X

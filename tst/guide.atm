require "atmos.env.clock"
val S = require "atmos.streams"

;; 1. Tasks & Events

;; 1.1
do {
    print "-=-=- 1.1 -=-=-"
    func T () {
        await(false)
    }
    pin t1 = spawn T()     ;; starts `t1`
    pin t2 = spawn T()     ;; starts `t2`
    print(t1, t2)          ;; t1 & t2 started and are now suspended
}

;; 1.2
do {
    print "-=-=- 1.2 -=-=-"
    func T (i) {
        await :X
        print("task " ++ i ++ " awakes from X")
    }
    spawn T(1)
    spawn T(2)
    emit :X
        ;; "task 1 awakes from X"
        ;; "task 2 awakes from X"
}

;; 2. External Environments

;; 2.1
do {
    print "-=-=- 2.1 -=-=-"
    spawn {
        await :X.A      ;; awakes when "x" emits :X.A
        print("terminates after X.A")
    }
    emit :X.A
}

;; 2.2
do {
    print "-=-=- 2.2 -=-=-"
    print "Counts 5 seconds:"
    loop _ in 5 {
        await @.100
        print "1 second..."
    }
    print "5 seconds elapsed."
}

;; 3. Lexical Structure

;; 3.1
do {
    print "-=-=- 3.1 -=-=-"
    print "1"
    spawn {
        print "a1"
        await :X
        print "a2"
    }
    print "2"
    spawn {
        print "b1"
        await :X
        print "b2"
    }
    print "3"
    emit :X
    print "4"
}

;; 3.2
do {
    print "-=-=- 3.2 -=-=-"
    spawn {
        spawn {
            await :Y    ;; never awakes after :X occurs
            print "never prints"
        }
        await :X        ;; awakes and aborts the whole task hierarchy
        print "awakes from X"
    }
    emit :X
    emit :Y
}

;; 3.3
do {
    print "-=-=- 3.3 -=-=-"
    spawn {
        spawn {
            defer {
                print "nested task aborted"
            }
            await(false) ;; never awakes
        }
        ;; will abort nested task
    }
}

;; 3.4
do {
    print "-=-=- 3.4 -=-=-"
    print '1'
    do {
        spawn {
            defer {
                print 'x'
            }
            await(false)
        }
        defer {
            print 'y'
        }
    }
    print '2'
    ;; 1, y, x, 2
}

;; 4. Compound Statements

;; 4.1
do {
    print "-=-=- 4.1 -=-=-"
    watching @1 {
        every @.100 {
            print "100 ms elapses"    ;; prints this message every second
        }
    }
}

;; 4.2
do {
    print "-=-=- 4.2 -=-=-"
    spawn {
        watching @1 {
            await :X
            print "X happens before 1s" ;; prints unless 1 second elapses
        }
    }
    emit :X
}

;; 4.3
do {
    print "-=-=- 4.3 -=-=-"
    spawn {
        par_and {
            await :X
        } with {
            await :Y
        } with {
            await :Z
        }
        print "X, Y, and Z occurred"
    }
    emit 'X'
    emit 'Z'
    emit 'Y'
}

;; 5. Functional Streams

;; 5.1
do {
    print "-=-=- 5.1 -=-=-"
    spawn {
        S.fr_await(:X)
            ::tap(xprint)
            ::filter \{ (it.v%2) == 1 }
            ::map \{ it.v }
            ::tap(print)
            ::to()
    }
    loop i in 10 {
        await @.1
        emit :X @{v=i}
    }
}

;; 5.2
do {
    print "-=-=- 5.2 -=-=-"
    func T () {
        await :X
        await :Y
    }
    spawn {
        S.fr_await(T)           ;; XY, XY, ...
            ::zip(S.from(1))    ;; {XY,1}, {XY,2} , ...
            ::map \{ it[2] }    ;; 1, 2, ...
            ::take(2)           ;; 1, 2
            ::tap(print)
            ::to()
    }
    emit :X
    emit :X
    emit :Y     ;; 1
    emit :X
    emit :Y     ;; 2
    emit :Y
}

;; 6. More about Tasks

;; 6.1
do {
    print "-=-=- 6.1 -=-=-"
    func T () {
        set pub = 10
    }
    pin t = spawn T()
    print(t.pub) ;; 10
}

;; 6.2
do {
    print "-=-=- 6.2 -=-=-"
    func T (id, ms) {
        set pub = id
        print(:start, id, ms)
        await @.ms
        print(:stop, id, ms)
    }
    do {
        pin ts = tasks()
        loop i in 10 {
            spawn [ts] T(i, math.random(500,1500))
        }
        await @1
        loop _,t in ts {
            print(t.pub)
        }
    }
}

;; 6.3
do {
    print "-=-=- 6.3 -=-=-"
    pin t = spawn (\{
        await :X
        print "awakes from X"
    }) ()
    toggle t(false)
    emit :X     ;; ignored
    print :ok
    toggle t(true)
    emit :X     ;; awakes
}

;; 6.4
do {
    print "-=-=- 6.4 -=-=-"
    spawn {
        toggle :X {
            every @.100 {
                print "100ms elapses"
            }
        }
    }
    print 'off'
    emit(:X, false)    ;; body above toggles off
    await @1
    print 'on'
    emit(:X, true)     ;; body above toggles on
    await @1
}

;; 7. Errors

do {
    print "-=-=- 7.1 -=-=-"
    func T () {
        spawn {
            await :X
            throw :Y
        }
        await(false)
    }
    spawn {
        val ok, err = catch :Y {
            spawn T()
            await(false)
        }
        print(ok, err)
    }
    emit :X
    ;; "false, Y"
}

do {
    print "-=-=- 7.2 -=-=-"
    func T (id) {
        await(:X, id)
        throw :error
    }
    pin ts = tasks()
    spawn [ts] T(1)
    spawn [ts] T(2)
    spawn [ts] T(3)
    emit(:X, 2)
}
